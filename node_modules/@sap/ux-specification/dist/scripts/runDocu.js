"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const d3_1 = require("d3");
const jquery_1 = __importDefault(require("jquery"));
// svg element close icon for tooltip
const closeIcon = `<svg id="close-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g>
                <path
                    fill-rule="evenodd"
                    clip-rule="evenodd"
                    d="M3.71313 3L3.00699 3.7049L6.79636 7.497L3 11.2941L3.70714 12L7.5025 8.20391L11.2939 11.996L12 11.2901L8.20863 7.497L11.994 3.71089L11.2869 3.00499L7.5025 6.7901L3.71313 3Z"
                    fill="#C5C5C5"
                />
            </g>
        </svg>`;
// dimensions of the tree container
const margin = { top: 0, right: 0, bottom: 0, left: 0 };
let innerHeight, innerWidth;
(innerWidth = document.body.clientWidth), (innerHeight = document.body.clientHeight);
// helper variables
const duration = 450, resetTreeButton = jquery_1.default('#resetTree'), expandTreeButton = jquery_1.default('#expandTree'), searchResult = jquery_1.default('ul#search-result'), searchInput = jquery_1.default('#search-input'), searchClose = jquery_1.default('#search-close-icon'), searchIcon = jquery_1.default('#search-icon');
let i = 0, maxLabelLength = 0;
// sets the tree layout and assigns the size
const treeLayout = d3_1.tree().size([innerHeight, innerWidth]);
// assigns and calculates the data required for the nodes and links
const root = d3_1.hierarchy(treeData, function (d) {
    return d.children;
});
// assign position of root
root.x0 = innerHeight / 2;
root.y0 = 0;
// create tooltip for description
const tooltipDiv = d3_1.select('body').append('div').style('opacity', 1e-6).attr('class', 'tooltip');
// function to remove tooltip
function removeTooltip() {
    tooltipDiv.style('opacity', 1e-6);
    tooltipDiv.style('display', 'none');
}
// define zoom function for zoomable tree
function zoomTree(event) {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    svgGroup.attr('transform', event.transform);
    removeTooltip();
}
// define the zoom listener which calls the zoom function
const zoomListener = d3_1.zoom().scaleExtent([0.3, 3]).on('zoom', zoomTree);
// select svg container for tree and set attributes
const svg = d3_1.select('svg#tree-container').attr('width', innerWidth).attr('height', innerHeight).call(zoomListener);
// create group element for all tree elements
const svgGroup = svg.append('g').attr('id', 'svg-group').attr('transform', `translate(${margin.left},${margin.top})`);
// determine the coordinates of an svg element
function getBB(selection) {
    selection.each(function (d) {
        d.bbox = this.getBBox();
        return d.bbox;
    });
}
// function to split CamelCase
function splitName(elem) {
    const splitElem = elem
        .split(/(?=[A-Z])/)
        .map(function (p) {
        return p.charAt(0).toUpperCase() + p.slice(1);
    })
        .join(' ');
    return splitElem;
}
// function to create the elements used in the tooltip depending on given data
const tooltipElements = function (d) {
    const closeButton = '<div id="tooltip_close-button">' + closeIcon + '</div>', name = '<div class="tip_prop">' + d.data.name + ' </div>', description = '<div class="tip_desc">' + d.data.description + '</div>', type = '<div class="tip_type">' + d.data.type + '</div>', enums = '<div class="tip_enums">' + d.data.type.replaceAll('|', ' | ') + '</div>', controlType = '<div class="tip_control">' + d.data.control + '</div>';
    let elements = closeButton;
    elements += name;
    // checks which data exist
    if (d.data.description)
        elements += description;
    if (d.data.type) {
        elements += '<div class="tip_type-container">';
        if (d.data.type.includes('|')) {
            elements += enums;
        }
        else {
            elements += type;
        }
    }
    if (d.data.artifact)
        elements += '<div class="tip_type">' + d.data.artifact + '</div>';
    if (d.data.control)
        elements += controlType;
    if (d.data.type)
        elements += '</div>';
    return elements;
};
// function for collapsing nodes
function collapse(d) {
    if (d.children) {
        //d.children = expanded children
        d._children = d.children;
        d._children.forEach(collapse);
        d.children = null;
    }
}
// function for expanding nodes
function expand(d) {
    if (d._children) {
        //d._children = collapes children
        d.children = d._children;
        d._children = null;
    }
    if (d.children) {
        const count = d.children.length;
        for (let i = 0; i < count; i++) {
            if (d.children[i].name) {
                expand(d.children[i]);
            }
        }
    }
}
// function to expand all nodes
function expandAll(d) {
    if (d._children) {
        d.children = d._children;
        d._children = null;
    }
    const children = d.children ? d.children : d._children;
    if (children)
        children.forEach(expandAll);
}
// function to toggle children
function toggleChildren(d) {
    if (d.children)
        collapse(d);
    else if (d._children)
        expand(d);
    return d;
}
// function to walk through all nodes
function visit(parent, visitFn, childrenFn) {
    if (!parent)
        return;
    visitFn(parent);
    const children = childrenFn(parent);
    if (children) {
        const count = children.length;
        for (let i = 0; i < count; i++) {
            visit(children[i], visitFn, childrenFn);
        }
    }
}
// function to center the tree or specific node
function centerNode(source, ratio) {
    const r = ratio ? ratio : 2, node = d3_1.zoomTransform(svg.node());
    let x = -source.y0, y = -source.x0;
    x = x * node.k + innerWidth / r;
    y = y * node.k + innerHeight / 2;
    d3_1.select('svg#tree-container')
        .transition()
        .duration(duration)
        .call(zoomListener.transform, d3_1.zoomIdentity.translate(x, y).scale(node.k));
}
// function to resize tree
function resize() {
    innerWidth = jquery_1.default(window).width();
    innerHeight = jquery_1.default(window).height();
    svg.attr('width', innerWidth);
    svg.attr('height', innerHeight);
    centerNode(root, 2.5);
}
// function to draw the links between the nodes
function diagonal(d) {
    let nodeGroup, width = 0;
    if (d.source.id)
        nodeGroup = d3_1.select('#n-' + d.source.id).node();
    // get width of node group element to set path accordingly
    if (nodeGroup)
        width = nodeGroup.getBBox().width;
    const path = 'M' + (d.source.y + width + 20) + ',' + d.source.x + 'H' + (d.target.y - 15) + 'V' + d.target.x + ('h' + 15);
    return path;
}
// function to create the path to nodes for search
function getNodePath(node, path) {
    const p = path || [], parent = node.parent;
    if (parent) {
        const children = parent.children || parent._children;
        p.unshift(children.indexOf(node));
        return getNodePath(parent, p);
    }
    else
        return p;
}
// function to animate the searched node
function flashNode(node) {
    let t = 4;
    // selects the searched node
    const text = jquery_1.default('#n-' + node.id + ' text');
    while (t--)
        text.fadeTo(350, 0).fadeTo(350, 1);
}
// function to display tooltip depending on data
function clickTitle(event, d) {
    if (d.data.description || d.data.type) {
        tooltipDiv.transition().duration(300).style('opacity', 1).style('display', 'flex');
        tooltipDiv.html(tooltipElements(d));
        d3_1.select('#tooltip_close-button').on('click', function () {
            removeTooltip();
        });
    }
    else if (!d.data.type) {
        removeTooltip();
    }
    // get dimensions of svg container to position tooltip
    const out_width = svg.node().getBoundingClientRect().width - 420;
    const out_height = svg.node().getBoundingClientRect().height - 300;
    if (event.pageX > out_width && event.pageY > out_height) {
        tooltipDiv
            .style('top', event.pageY - 20 + 'px')
            .style('left', event.pageX - 20 + 'px')
            .style('transform', 'translate(-100%, -100%)');
    }
    else if (event.pageX > out_width && !(event.pageY > out_height)) {
        tooltipDiv
            .style('top', event.pageY + 20 + 'px')
            .style('left', event.pageX - 20 + 'px')
            .style('transform', 'translate(-100%, 0)');
    }
    else if (!(event.pageX > out_width) && event.pageY > out_height) {
        tooltipDiv
            .style('top', event.pageY - 20 + 'px')
            .style('left', event.pageX + 20 + 'px')
            .style('transform', 'translate(0, -100%)');
    }
    else {
        tooltipDiv
            .style('top', event.pageY + 20 + 'px')
            .style('left', event.pageX + 20 + 'px')
            .style('transform', 'translate(0, 0)');
    }
}
// function to draw the tree
function update(source) {
    // function to compute the height of the tree depending on the children
    const levelWidth = [1];
    function childCount(level, n) {
        if (n.children && n.children.length > 0) {
            if (levelWidth.length <= level + 1)
                levelWidth.push(0);
            levelWidth[level + 1] += n.children.length;
            n.children.forEach(function (d) {
                childCount(level + 1, d);
            });
        }
    }
    // compute the new height depending on children
    childCount(0, root);
    const newHeight = d3_1.max(levelWidth) > 20 && d3_1.max(levelWidth) < 40 ? d3_1.max(levelWidth) * 55 : d3_1.max(levelWidth) * 45; // pixels per line
    // set the new tree layout
    treeLayout.size([newHeight, innerWidth]);
    const tree = treeLayout(root);
    // assign the nodes and links
    const nodes = tree.descendants(), links = tree.links();
    // determine the horizontal spacing of the nodes
    nodes.forEach(function (d) {
        // Normalize for fixed-depth
        // d.y = d.depth * 300;
        d.y = d.depth * (maxLabelLength * 5);
    });
    // ********************************** NODE SECTION **********************************
    // declare the nodes
    const node = svgGroup.selectAll('g.node').data(nodes, function (d) {
        return d.id || (d.id = ++i);
    });
    // enter the nodes
    const nodeEnter = node
        .enter()
        .append('g')
        .attr('class', 'node')
        .attr('id', function (d) {
        return 'n-' + d.id;
    })
        .attr('transform', function () {
        return 'translate(' + source.y0 + ',' + source.x0 + ')';
    });
    // add labels to nodes
    nodeEnter
        .append('text')
        .attr('class', 'node-text')
        .attr('dy', '.35em')
        .attr('x', 10)
        .attr('text-anchor', 'start')
        .attr('text-decoration', function (d) {
        return d.data.description ? 'underline' : 'none';
    })
        .attr('cursor', function (d) {
        return d.data.description ? 'pointer' : 'default';
    })
        .text(function (d) {
        const name = splitName(d.data.name);
        return name;
    })
        // needs to be called with data to pass the description to the tooltip
        .on('click', function (event, d) {
        clickTitle(event, d);
    })
        // return the bounding box of node to set elements accordingly
        .call(getBB);
    // filter nodes that contain children
    const nodeWithChildren = nodeEnter.filter(function (d) {
        if (d.data.children.length > 0)
            return d.data.children;
    });
    // add element with amount of children to nodes
    nodeWithChildren
        .append('text')
        .attr('class', 'node-child-text')
        .attr('x', function (d) {
        return d.bbox.x + d.bbox.width + 20;
    })
        .attr('dy', '.35em')
        .text(function (d) {
        return d.data.children.length;
    })
        .call(getBB);
    nodeWithChildren
        .insert('rect', 'text')
        .attr('class', 'node-child')
        .attr('x', function (d) {
        return d.bbox.x - 7;
    })
        .attr('y', function (d) {
        return d.bbox.y - 1;
    })
        .attr('width', function (d) {
        return d.bbox.width + 14;
    })
        .attr('height', function (d) {
        return d.bbox.height + 2;
    })
        .attr('ry', '8');
    // add clickable circle element to nodes with children
    nodeWithChildren
        .append('text')
        .attr('class', 'node-circle-text')
        .attr('x', function (d) {
        return d.bbox.x + d.bbox.width + 15;
    })
        .attr('dy', '.35em')
        .text('+')
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        .on('click', click)
        .call(getBB);
    nodeWithChildren
        .insert('circle', 'text')
        .attr('class', 'node-circle')
        .attr('r', function (d) {
        return d.bbox.height / 2;
    })
        .attr('cx', function (d) {
        return d.bbox.x + d.bbox.width / 2;
    })
        .attr('cy', function (d) {
        return d.bbox.y + d.bbox.height / 2;
    })
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        .on('click', click);
    // merge nodes to handle updates
    const nodeUpdate = nodeEnter.merge(node);
    // transition nodes to the correct position
    nodeUpdate
        .transition()
        .duration(duration)
        .attr('transform', function (d) {
        return 'translate(' + d.y + ',' + d.x + ')';
    });
    // change style of node elements on update
    nodeUpdate
        .select('rect')
        .style('fill', function (d) {
        return d._children ? 'var(--vscode-foreground)' : 'var(--vscode-editor-background)';
    })
        .style('stroke', function (d) {
        return d._children ? 'none' : 'var( --vscode-editorWidget-border)';
    })
        .style('stroke-width', function (d) {
        return d._children ? 'none' : '1px solid';
    });
    nodeUpdate.select('circle').style('fill', function (d) {
        return d._children ? 'var(--vscode-button-background)' : 'var(--vscode-button-secondaryBackground)';
    });
    nodeUpdate.select('.node-child-text').style('fill', function (d) {
        return d._children ? 'var( --vscode-editor-background)' : 'var(--vscode-foreground)';
    });
    nodeUpdate.select('.node-circle-text').text(function (d) {
        return d._children ? '+' : '−';
    });
    nodeUpdate.selectAll('text').style('fill-opacity', 1);
    // remove nodes on exit
    const nodeExit = node
        .exit()
        .transition()
        .duration(duration)
        .attr('transform', function () {
        return 'translate(' + source.y + ',' + source.x + ')';
    })
        .remove();
    // reduce size and opacity of nodes on exit
    nodeExit.select('circle').attr('r', 1e-6).style('fill-opacity', 1e-6);
    nodeExit.selectAll('rect').attr('x', 1e-6).style('fill-opacity', 1e-6);
    nodeExit.selectAll('text').style('fill-opacity', 1e-6);
    // ********************************** LINK SECTION ********************************
    // declare the links based on unique target id’s
    const link = svgGroup.selectAll('path.link').data(links, function (d) {
        return d.target.id;
    });
    // enter the links and set path
    const linkEnter = link
        .enter()
        .insert('path', 'g')
        .attr('class', 'link')
        .attr('d', function () {
        const o = {
            x: source.x0,
            y: source.y0
        };
        return diagonal({
            source: o,
            target: o
        });
    });
    // merge links to handle update
    const linkUpdate = linkEnter.merge(link);
    // transition links to the correct position
    linkUpdate.transition().duration(duration).attr('d', diagonal);
    // remove links on exit
    link.exit()
        .transition()
        .duration(duration)
        .attr('d', function () {
        const o = {
            x: source.x,
            y: source.y
        };
        return diagonal({
            source: o,
            target: o
        });
    })
        .remove();
    // store position of elements for transition
    nodes.forEach(function (d) {
        d.x0 = d.x;
        d.y0 = d.y;
    });
}
// establish maxLabelLength for horizontal spacing of nodes
visit(treeData, function (d) {
    maxLabelLength = Math.max(d.name.length + 25, maxLabelLength);
}, function (d) {
    return d.children && d.children.length > 0 ? d.children : null;
});
// collapse all nodes at root or after the second level
// collapse(root);
root.children.forEach(collapse);
// update and draw the tree
update(root);
centerNode(root, 2.5);
// function to expand the selected node path from search
function expandNodePath(path) {
    let node = root; //start with root
    for (let i = 0; i < path.length; i++) {
        if (node._children)
            expand(node);
        node = node.children[path[i]];
    }
    update(root);
    centerNode(node, 2);
    return node;
}
// function to filter the items in search list
function filterSearchItems(searchTerm) {
    let i = 0;
    jquery_1.default('#search-result li').each(function () {
        const currentText = jquery_1.default(this).text().toUpperCase(), trimText = currentText.replace(/\s/g, '');
        if (currentText.indexOf(searchTerm) >= 0 || trimText.indexOf(searchTerm) >= 0) {
            searchResult.show();
            jquery_1.default(this).show();
            i++;
        }
        else
            jquery_1.default(this).hide();
        if (i == 0)
            searchResult.hide();
    });
}
// function to create the search list with items
function createSearch(items) {
    jquery_1.default.each(items, function (i, v) {
        const data = v.split('|');
        // append the elements of the search list
        jquery_1.default('<li/>').attr('data-path', data[1]).text(splitName(data[0])).appendTo(searchResult);
    });
    // function to handle search input
    searchInput.on('keyup', function () {
        let searchValue = jquery_1.default(this).val();
        searchValue = searchValue.toUpperCase().trim();
        if (searchValue.length > 0) {
            filterSearchItems(searchValue);
            searchClose.show();
            // searchResult.show();
        }
        else {
            searchResult.hide();
            searchClose.hide();
        }
    });
    // function to handle click on search item
    jquery_1.default('#search-result li').on('click', function (e) {
        const path = jquery_1.default(e.target).attr('data-path'), node = expandNodePath(path.split('-'));
        flashNode(node);
    });
    // function to handle click on close button
    searchClose.on('click', function () {
        searchInput.val(null);
        searchResult.hide();
        searchClose.hide();
        searchIcon.show();
    });
    searchInput.on('focus', function () {
        searchIcon.hide();
    });
    searchInput.on('focusout ', function () {
        searchIcon.show();
    });
}
// function to set up the search
function setupSearch() {
    const searchList = [];
    visit(root, 
    // creates the search list with paths to the nodes
    function (current) {
        if (current)
            searchList.push(current.data.name + '|' + getNodePath(current, []).join('-'));
    }, function (current) {
        return current.children || current._children;
    });
    // removes name of floorplan from search list
    searchList.splice(searchList.indexOf(root.data.name + '|'), 1);
    searchList.sort();
    createSearch(searchList);
}
setupSearch();
// add icon of floorplan to root
jquery_1.default('#n-1').append(floorPlanIcon);
d3_1.select('#floorPlan-icon').attr('y', -7).attr('x', -15);
// toggle children on click
function click(event, d) {
    // click suppressed
    if (event.defaultPrevented)
        return;
    d = toggleChildren(d);
    update(d);
    centerNode(d, 2);
    removeTooltip();
}
// function to reset the tree
resetTreeButton.on('click', function () {
    root.children.forEach(collapse);
    update(root);
    centerNode(root, 2.5);
});
// function to expand all nodes
expandTreeButton.on('click', function () {
    expandAll(root);
    update(root);
    centerNode(root, 5);
});
d3_1.select(window).on('resize', resize);
//# sourceMappingURL=runDocu.js.map