"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This script extracts all existing documentation (i.e. descriptions) from the generic schemas of a certain OData version (V2 or V4).
 * All descriptions are collected in an Excel sheet that you afterwards can find under dist/documentation: it is named Specificationv2.xslx or Specificationv4.xslx, depending on the chosen version.
 * You can find one worksheet for each generic schema file.
 *
 * The script expects that you supply an argument --version with either v2 or v4.
 * You can also start it from one of the debugger scripts named in launch.json: "Extract V2 documentation" or "Extract V4 documentation".
 */
const ux_specification_types_1 = require("@sap/ux-specification-types");
const path_1 = require("path");
const fs = __importStar(require("fs"));
const excel = __importStar(require("excel4node"));
/**
 * Handles reference ($ref) within the schema, finds the corresponding definition
 * @param schema - Object representing the whole generic schema
 * @param reference - Content for the $ref property
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 * @param description - The description of the current hierarchy element
 * @param additionalMetadata - Additional information about the current hierarchy element, separated by ';'
 */
function dereference(schema, reference, output, definition, description, additionalMetadata) {
    const currentDefinition = reference.split('#/definitions/')[1];
    try {
        parseSchema(schema, schema['definitions'][currentDefinition], output, definition, description, additionalMetadata);
    }
    catch (error) {
        console.log(error);
    }
}
/**
 * Handles one property of a sub-schema
 * @param schema - Object representing the whole generic schema
 * @param subSchema - Object representing the current sub-structure of the schema
 * @param property - Name of the property within the subSchema
 * @param output  - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 */
function processElement(schema, subSchema, property, output, definition) {
    function addMetadata() {
        if (additionalMetadata) {
            output.push(definition + ';' + `TYPE_${element['type']}` + additionalMetadata + ';' + element['description']);
        }
        else {
            output.push(definition + ';' + `TYPE_${element['type']}` + ';' + element['description']);
        }
    }
    if (['$schema', 'id', 'pages', 'home', 'custom', '1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(property)) {
        return;
    }
    const element = subSchema[property];
    const property2write = property === '^[0-9]+$' ? 'Instance (key = number)' : property;
    definition = definition ? definition + ';' + property2write : property2write;
    if (property === 'columns') {
        definition = definition + ';columnId';
    }
    if (property === 'sections') {
        definition = definition + ';sectionId';
    }
    if (property === 'cards') {
        definition = definition + ';cardKey';
    }
    let additionalMetadata;
    if (element['artifactType']) {
        additionalMetadata = `;ARTIFACT_${element['artifactType']}`;
    }
    if (element['controlType']) {
        additionalMetadata += `;CONTROL_${element['controlType']}`;
    }
    if (element['description']) {
        if (element['$ref']) {
            dereference(schema, element['$ref'], output, definition, element['description'], additionalMetadata);
            return;
        }
        else if (element['anyOf']) {
            handleAnyOf(schema, element['anyOf'], output, definition, element['description'], element, additionalMetadata);
            return;
        }
        if (element['type'] && element['items']) {
            const reference = element['items']['$ref'] || (element['items'][0] && element['items'][0]['$ref']);
            if (reference) {
                dereference(schema, reference, output, definition, element['description'], additionalMetadata);
            }
            else {
                addMetadata();
            }
            return;
        }
        addMetadata();
    }
    // Temporary as Description is not maintained for some properties - description should be added
    if (!element['description'] && element['type']) {
        if (additionalMetadata) {
            output.push(definition + ';' + `TYPE_${element['type']}` + additionalMetadata);
        }
        else {
            output.push(definition + ';' + `TYPE_${element['type']}`);
        }
    }
    if (element['$ref']) {
        dereference(schema, element['$ref'], output, definition);
    }
    else {
        parseSchema(schema, element, output, definition);
    }
}
/**
 * Special handling of anyOf elements of a JSON schema
 * @param schema - Object representing the whole generic schema
 * @param anyOfSchema - Object representing the current sub-structure of the schema
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 * @param description - The description of the current hierarchy element
 * @param element - Object representing the sub-structure of the current hierarchy element
 * @param additionalMetadata - Additional information about the current hierarchy element, separated by ';' (e.g. artifactType)
 */
function handleAnyOf(schema, anyOfSchema, output, definition, description, element, additionalMetadata) {
    for (let index = 0; index < anyOfSchema.length; index++) {
        const anyOfSchemaElement = anyOfSchema[index];
        if (element?.['pattern'] && anyOfSchemaElement['type'] === 'string') {
            return;
        }
        if (Object.keys(anyOfSchemaElement)[0] === '$ref') {
            dereference(schema, anyOfSchemaElement['$ref'], output, definition, description, additionalMetadata);
        }
        else {
            parseSchema(schema, anyOfSchemaElement, output, definition, description, additionalMetadata);
        }
    }
}
/**
 * Parses a sub-structure of the schema
 * @param schema - Object representing the whole generic schema
 * @param subSchema - Object representing the current sub-structure of the schema
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param definition - The current hierarchy element (list of path parts separated by ';')
 * @param description - The description of the current hierarchy element
 * @param additionalMetadata - Additional information about the current hierarchy element, separated by ';' (e.g. artifactType)
 */
function parseSchema(schema, subSchema, output, definition, description, additionalMetadata) {
    if (Object.keys(subSchema) && Object.keys(subSchema)[0] === 'anyOf') {
        handleAnyOf(schema, subSchema['anyOf'], output, definition);
        return;
    }
    for (const property in subSchema['properties']) {
        if (property === '$ref') {
            dereference(schema, subSchema['properties']['$ref'], output, definition);
        }
        else if (property === 'anyOf') {
            handleAnyOf(schema, subSchema['properties']['anyOf'], output, definition);
        }
        else {
            processElement(schema, subSchema['properties'], property, output, definition);
        }
    }
    for (const property in subSchema['patternProperties']) {
        if (property === '$ref') {
            dereference(schema, subSchema['patternProperties']['$ref'], output, definition);
        }
        else if (property === 'anyOf') {
            handleAnyOf(schema, subSchema['patternProperties']['anyOf'], output, definition);
        }
        else {
            processElement(schema, subSchema['patternProperties'], property, output, definition);
        }
    }
    for (const property in subSchema['additionalProperties']) {
        if (property === '$ref') {
            dereference(schema, subSchema['additionalProperties']['$ref'], output, definition);
        }
        else if (property === 'anyOf') {
            handleAnyOf(schema, subSchema['additionalProperties']['anyOf'], output, definition);
        }
        else {
            processElement(schema, subSchema['additionalProperties'], property, output, definition);
        }
    }
    if (subSchema['enum'] && description) {
        if (additionalMetadata) {
            output.push(definition + ';' + `TYPE_${[subSchema['enum'].join('|')]}` + additionalMetadata + ';' + description);
        }
        else {
            output.push(definition + ';' + `TYPE_${[subSchema['enum'].join('|')]}` + ';' + description);
        }
    }
    else if (subSchema['type'] && description) {
        if (additionalMetadata) {
            output.push(definition + ';' + `TYPE_${subSchema['type']}` + additionalMetadata + ';' + description);
        }
        else {
            output.push(definition + ';' + `TYPE_${subSchema['type']}` + ';' + description);
        }
    }
}
/**
 * Fills an excel4node workbook based on csv like information
 * @param workbook - Excel workbook (excel4node format)
 * @param output - Array of descriptions with assigned hierarchy elements, all separated by ';' (csv like)
 * @param file - file name of the original schema
 */
function writeToExcel(workbook, output, file) {
    //filter output to remove duplicated lines due to different table types (anyOf)
    output = output.filter((e, i, a) => a.indexOf(e) === i);
    const sheetName = file.split('.')[0];
    const worksheet = workbook.addWorksheet(sheetName);
    worksheet.headerFooter = { evenHeader: output[0] };
    // Create a reusable style
    const style = workbook.createStyle({
        font: {
            //color: '#800000',
            size: 12
        },
        numberFormat: '$#,##0.00; ($#,##0.00); -'
    });
    for (let rowIndex = 1; rowIndex < output.length; rowIndex++) {
        const element = output[rowIndex];
        const cellArray = element.split(';');
        for (let cellIndex = 0; cellIndex < cellArray.length; cellIndex++) {
            const cell = cellArray[cellIndex];
            worksheet
                .cell(rowIndex, cellIndex + 1)
                .string(cell)
                .style(style);
        }
    }
}
function generateIxiaSoftFormat(output, file, version) {
    //filter output to remove duplicated lines due to different table types (anyOf)
    output = output.filter((e, i, a) => a.indexOf(e) === i);
    let iXiaFormat = `<simpletable frame="all" relcolwidth="1* 1*" id="simpletable_uqj_klr_jlb">
        <sthead>
            <stentry> Settings </stentry>
            <stentry> Description </stentry>
        </sthead>
    `;
    const fileName = file.split('.')[0];
    for (let rowIndex = 1; rowIndex < output.length; rowIndex++) {
        const element = output[rowIndex];
        const cellArray = element.split(';');
        let setting = '{';
        iXiaFormat = iXiaFormat + `\t<strow>\n`;
        for (let cellIndex = 0; cellIndex < cellArray.length - 1; cellIndex++) {
            let cell = cellArray[cellIndex];
            if (['0', '1'].includes(cell)) {
                cell = 'variantKey' + cell;
            }
            if (cellArray[cellIndex + 1].includes('TYPE')) {
                setting = setting + `"${cell}": ${cellArray[cellIndex + 1].split('_')[1]}`;
                let noOfOpeningBraces = setting.match(/{/g).length;
                while (noOfOpeningBraces > 0) {
                    setting = setting + '}';
                    noOfOpeningBraces--;
                }
                iXiaFormat = iXiaFormat + `\t\t<stentry> ${setting} </stentry>\n`;
            }
            else {
                setting = setting + `"${cell}": {`;
            }
        }
        // add description to the table
        iXiaFormat = iXiaFormat + `\t\t<stentry> ${cellArray[cellArray.length - 1]} </stentry>\n\t</strow>\n`;
    }
    iXiaFormat = iXiaFormat + `</simpletable>`;
    const outDir = path_1.join('dist', 'documentation');
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir);
    }
    const outFile = path_1.join(outDir, 'Specification' + version + fileName + '.txt');
    fs.writeFile(outFile, iXiaFormat, (err) => {
        if (err)
            throw err;
        console.log(`${outFile} was succesfully saved!`);
    });
}
function createTreeData(output, floorPlan, odataVersion, specVersion) {
    let root;
    const treeData = {
        name: floorPlan,
        description: 'SAP Fiori elements for OData ' +
            odataVersion.toUpperCase() +
            '<br>@sap/ux-specification version ' +
            specVersion,
        type: 'schema',
        children: []
    };
    function find(string) {
        if (string.includes('ARTIFACT_')) {
            return 'artifact';
        }
        else if (string.includes('CONTROL_')) {
            return 'control';
        }
        else {
            return 'description';
        }
    }
    function addKeyValue(element, index, elementsArray) {
        if (element.includes('TYPE_')) {
            root.type = element.split('_')[1];
            for (let i = index + 1; i < elementsArray.length; i++) {
                const match = find(elementsArray[i]);
                switch (match) {
                    case 'artifact':
                        if (elementsArray[i].split('_')[1] === 'FlexChange') {
                            root.artifact = 'UI5 flexibility';
                        }
                        else {
                            root.artifact = elementsArray[i].split('_')[1];
                        }
                        break;
                    case 'control':
                        root.control = elementsArray[i].split('_')[1];
                        break;
                    default:
                        root.description = elementsArray[i];
                }
            }
            return false;
        }
        else {
            for (let i = 0; i < root.children.length; i++) {
                if (element === root.children[i].name) {
                    root = root.children[i];
                    return true;
                }
            }
            root.children.push({
                name: element,
                children: []
            });
            root = root.children[root.children.length - 1];
            return true;
        }
    }
    output.forEach((line) => {
        const elements = line.split(';');
        root = treeData;
        elements.every(addKeyValue);
    });
    return treeData;
}
function createSVGIcon(floorPlan) {
    let svgFormat = `<svg id="floorPlan-icon" width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <g><path fill-rule="evenodd" clip-rule="evenodd" fill="#C5C5C5"`;
    const svgPathALP = `d="M9 13V14H6V13H9ZM5 13V14H2V13H5ZM13 13V14H10V13H13ZM9 11V12H6V11H9ZM5 11V12H2V11H5ZM13 11V12H10V11H13ZM5 9V10H2V9H5ZM9 9V10H6V9H9ZM13 9V10H10V9H13ZM3.986 1.998V6.024H1.965V1.998H3.986ZM6.99 4.01V6.01H4.99V4.01H6.99ZM10.008 3.019V6.01H8.008V3.019H10.008ZM13.005 1.998V6.011H11.005V1.998H13.005ZM1 14.988H14.988V7.995H1V14.988ZM1.001 6.994H14.989V1H1.001V6.994ZM1.00169 0C0.449309 0 0 0.448336 0 1.00075V14.9992C0 15.5517 0.449309 16 1.00169 16H14.9993C15.5517 16 16 15.5517 16 14.9992V1.00075C16 0.448336 15.5517 0 14.9993 0H1.00169Z"`;
    const svgPathLR = `d="M5 3.0028H2V2.0048H5V3.0028ZM6.0044 3.0028H9.0044V2.0048H6.0044V3.0028ZM10.0014 3.0028H13.0014V2.0048H10.0014V3.0028ZM1 14.993L0.997 4.995H14.988V14.988L1 14.993ZM14.988 0.995V3.994H0.996L0.995 1L14.988 0.995ZM14 7H10V6H14V7ZM11 9.0028H14V8.0048H11V9.0028ZM14 11H10V10H14V11ZM14 13.0028H11V12.0048H14V13.0028ZM6 12.999H9V12.001H6V12.999ZM9 10.999H6V10.001H9V10.999ZM6 8.999H9V8.001H6V8.999ZM9 6.999H6V6.001H9V6.999ZM2 12.999H5V12.001H2V12.999ZM5 11.0028H2V10.0048H5V11.0028ZM2 9.0028H5V8.0048H2V9.0028ZM5 6.999H2V6.001H5V6.999ZM14.993 0H0.995C0.446 0 0 0.446 0 0.995V14.993C0 15.542 0.446 15.988 0.995 15.988H14.993C15.542 15.988 15.988 15.542 15.988 14.993V0.995C15.988 0.446 15.542 0 14.993 0Z"`;
    const svgPathOP = `d="M9 13V14H6V13H9ZM9 11V12H6V11H9ZM13 9V10H10V9H13ZM9 9V10H6V9H9ZM5 9V10H2V9H5ZM14.989 7.996L14.988 14.989H1L1.001 7.996H14.989ZM3.998 2C5.1 2 5.996 2.896 5.996 3.998C5.996 5.1 5.1 5.996 3.998 5.996C2.896 5.996 2 5.1 2 3.998C2 2.896 2.896 2 3.998 2ZM14 4.0046V5.0046H8V4.0046H14ZM3.998 3C3.447 3 3 3.447 3 3.998C3 4.549 3.447 4.996 3.998 4.996C4.549 4.996 4.996 4.549 4.996 3.998C4.996 3.447 4.549 3 3.998 3ZM12.002 2V3H8V2H12.002ZM14.989 1.001V6.995H1.001V1L14.989 1.001ZM14.989 0H1.001C0.449 0 0 0.449 0 1.001V14.989C0 15.541 0.449 15.989 1.001 15.989H14.989C15.541 15.989 15.989 15.541 15.989 14.989V1.001C15.989 0.488429 15.6027 0.0646684 15.1056 0.00674636L14.989 0Z"`;
    const svgPathOVP = `d="M14.988 15.488V14.988H14.989L14.988 15.488ZM14.988 14.988H1V1H14.988V14.988ZM14.988 0H1C0.448 0 0 0.448 0 1V14.988C0 15.54 0.448 15.988 1 15.988H14.988C15.54 15.988 15.988 15.54 15.988 14.988V1C15.988 0.448 15.54 0 14.988 0ZM2.9917 7.037H7.0147V3.014H2.9917V7.037ZM7.5147 2.013H2.4907C2.2147 2.013 1.9907 2.237 1.9907 2.513V7.537C1.9907 7.813 2.2147 8.037 2.4907 8.037H7.5147C7.7907 8.037 8.0147 7.813 8.0147 7.537V2.513C8.0147 2.237 7.7907 2.013 7.5147 2.013ZM7.0147 13.014H2.9917V10.034H7.0147V13.014ZM2.4907 9.034H7.5147C7.7907 9.034 8.0147 9.258 8.0147 9.534V13.514C8.0147 13.791 7.7907 14.014 7.5147 14.014H2.4907C2.2147 14.014 1.9907 13.791 1.9907 13.514V9.534C1.9907 9.258 2.2147 9.034 2.4907 9.034ZM9.9847 9.034H13.0217V3.013H9.9847V9.034ZM13.5217 2.013H9.4847C9.2087 2.013 8.9847 2.237 8.9847 2.513V9.534C8.9847 9.81 9.2087 10.034 9.4847 10.034H13.5217C13.7987 10.034 14.0217 9.81 14.0217 9.534V2.513C14.0217 2.237 13.7987 2.013 13.5217 2.013ZM13.0217 13.006H9.9847V12.021H13.0217V13.006ZM9.4847 11.02H13.5217C13.7987 11.02 14.0217 11.244 14.0217 11.52V13.506C14.0217 13.782 13.7987 14.006 13.5217 14.006H9.4847C9.2087 14.006 8.9847 13.782 8.9847 13.506V11.52C8.9847 11.244 9.2087 11.02 9.4847 11.02Z"`;
    const name = floorPlan.toLowerCase();
    if (name.includes('analytical'))
        svgFormat += svgPathALP;
    else if (name.includes('listreport'))
        svgFormat += svgPathLR;
    else if (name.includes('objectpage'))
        svgFormat += svgPathOP;
    else if (name.includes('overviewpage'))
        svgFormat += svgPathOVP;
    else
        return undefined;
    svgFormat += `/></g></svg>`;
    return svgFormat;
}
function generateHTMLFormat(output, file, odataVersion) {
    //filter output to remove duplicated lines due to different table types (anyOf)
    output = output.filter((e, i, a) => a.indexOf(e) === i);
    output.shift();
    const nameFloorPlan = file.split('.')[0].replace(/Config/g, '');
    const rootName = __dirname.slice(0, __dirname.lastIndexOf('specification') + 13);
    const packageJson = JSON.parse(fs.readFileSync(path_1.join(rootName, 'package.json'), 'utf8'));
    //shortens spec version
    const specVersion = packageJson.version.includes('+') ? packageJson.version.split('+')[0] : packageJson.version;
    const svgIcon = createSVGIcon(nameFloorPlan);
    const treeData = createTreeData(output, nameFloorPlan, odataVersion, specVersion);
    const templateFilePath = path_1.join(rootName, 'scripts', 'templateDocu.html');
    //only create html if porperties exist
    if (treeData.children.length > 0) {
        let template;
        let outDir;
        try {
            template = fs.readFileSync(templateFilePath, 'utf8');
        }
        catch (e) {
            console.log(`Error: ${e.message}`);
        }
        template = template.replace(`'insertDataHere'`, JSON.stringify(treeData));
        if (svgIcon !== undefined)
            template = template.replace(`floorPlanIcon`, 'floorPlanIcon = `' + svgIcon + '`');
        odataVersion === 'v2'
            ? (outDir = path_1.join('dist', 'documentation', 'v2'))
            : (outDir = path_1.join('dist', 'documentation', 'v4'));
        if (!fs.existsSync(outDir))
            fs.mkdirSync(outDir, { recursive: true });
        const outFile = path_1.join(outDir, odataVersion + '-' + nameFloorPlan + '.html');
        fs.writeFile(outFile, template, (err) => {
            if (err)
                throw err;
            console.log(`${outFile} was successfully saved!`);
        });
    }
}
function copyFileToFolder() {
    const file = 'styleDocu.css';
    const src = path_1.join(__dirname, '..', 'scripts', file);
    const dest = path_1.join('dist', 'documentation', file);
    if (!fs.existsSync(dest)) {
        fs.copyFile(src, dest, (err) => {
            if (err)
                throw err;
            if (!err) {
                console.log(file + ' has been copied!');
            }
        });
    }
}
/**
 * Writes an Excel workbook to a file in the dist/documentation folder.
 * @param workbook - Excel workbook (excel4node format)
 * @param version - OData version
 */
function writeToFile(workbook, version) {
    const outDir = path_1.join('dist', 'documentation');
    if (!fs.existsSync(outDir)) {
        fs.mkdirSync(outDir);
    }
    const outFile = path_1.join(outDir, 'Specification' + version + '.xlsx');
    workbook.write(outFile);
}
/********************** Main ***************************/
function generateDocmentation() {
    const myArgs = process.argv.slice(2);
    let version;
    let format;
    myArgs.forEach((arg) => {
        const value = arg.split('=')[1];
        if (arg.includes('version')) {
            version = value;
        }
        else if (arg.includes('format')) {
            format = value;
        }
    });
    let directoryPath = '';
    switch (version) {
        case ux_specification_types_1.FioriElementsVersion.v2:
            directoryPath = path_1.join('schemas', 'v2');
            break;
        case ux_specification_types_1.FioriElementsVersion.v4:
            directoryPath = path_1.join('schemas', 'v4');
            break;
        default:
            console.log('Invalid version ' + version + '; processing stopped.');
            break;
    }
    if (directoryPath.length > 0) {
        const workbook = new excel.Workbook();
        fs.readdir(directoryPath, function (err, files) {
            if (err) {
                return console.log(err);
            }
            files.forEach((file) => {
                const filePath = path_1.join(directoryPath, file);
                const output = [filePath];
                const data = fs.readFileSync(filePath, 'utf8');
                const schema = JSON.parse(data);
                parseSchema(schema, schema, output);
                //console.log(output);
                if (format === 'excel') {
                    writeToExcel(workbook, output, file);
                }
                if (format === 'iXiaSoft') {
                    generateIxiaSoftFormat(output, file, version);
                }
                if (format === 'html') {
                    generateHTMLFormat(output, file, version);
                }
            });
            if (format === 'excel') {
                writeToFile(workbook, version);
            }
            if (format === 'html') {
                copyFileToFolder();
            }
        });
    }
}
generateDocmentation();
//# sourceMappingURL=extractDocu.js.map