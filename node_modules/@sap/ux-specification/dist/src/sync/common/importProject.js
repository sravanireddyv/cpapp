"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importProjectSchemaAndConfig = exports.importProjectSchema = exports.getEntitySetByEntitySetName = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
const generate_1 = require("../v2/generate");
const appProvider_1 = require("../v2/import/app/appProvider");
const ovpProvider_1 = require("../v2/import/app/ovpProvider");
const generate_2 = require("../v4/generate");
const app_1 = require("../v4/import/app");
const utils_1 = require("./utils");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../extensionLogger");
const i18n_1 = require("../../i18n/i18n");
const schemaAccess_1 = require("../../specification/schemaAccess");
/**
 * Generates an object comprising all generic schemas
 * @param {TemplateType} templateType - Template type
 * @param {FioriElementsVersion} fioriElementsVersion - Fiori Elements version
 * @returns {Object} genericSchemas
 */
async function getGenericSchemas(templateType, fioriElementsVersion) {
    const genericSchemas = {};
    let schemaTypes = [];
    schemaTypes = [ux_specification_types_1.SchemaType.Application];
    switch (templateType) {
        case ux_specification_types_1.TemplateType.ListReportObjectPageV2:
        case ux_specification_types_1.TemplateType.ListReportObjectPageV4:
        case ux_specification_types_1.TemplateType.AnalyticalListPageV4:
            schemaTypes.push(ux_specification_types_1.SchemaType.ListReport, ux_specification_types_1.SchemaType.ObjectPage);
            break;
        case ux_specification_types_1.TemplateType.AnalyticalListPageV2:
            schemaTypes.push(ux_specification_types_1.SchemaType.AnalyticalListPage, ux_specification_types_1.SchemaType.ObjectPage);
            break;
        case ux_specification_types_1.TemplateType.OverviewPageV2:
            schemaTypes.push(ux_specification_types_1.SchemaType.OverviewPage);
            break;
        case ux_specification_types_1.TemplateType.FreestylePageV4:
            schemaTypes.push(ux_specification_types_1.SchemaType.FreestylePage, ux_specification_types_1.SchemaType.ObjectPage);
            break;
        default:
            break;
    }
    for (const schemaType of schemaTypes) {
        const schemaFile = utils_1.getSchemaFilePath(schemaType);
        genericSchemas[schemaFile.filename] = await schemaAccess_1.getGenericSchema(fioriElementsVersion, schemaType);
    }
    return genericSchemas;
}
/**
 * Get the relevant UI.ListItem and UI.Facet entity sets
 * @param {ConvertedMetadata} oDataServiceAVT - Annotations as converted by AVT
 * @returns a fitered list of facet and line item annotations
 */
function getAnnotationsForUi(oDataServiceAVT) {
    const filteredEntityTypes = {
        Facets: [],
        LineItems: []
    };
    const allEntityTypes = oDataServiceAVT?.entityTypes;
    if (!allEntityTypes) {
        return filteredEntityTypes;
    }
    const alias = utils_1.findAlias(ux_specification_types_1.UIVOCABULARY, oDataServiceAVT);
    for (const entity of allEntityTypes) {
        if (!entity.annotations || !entity.annotations[alias]) {
            continue;
        }
        const { LineItem, Facets } = entity.annotations[alias];
        if (LineItem &&
            !LineItem.qualifier &&
            LineItem.find((li) => li.$Type === "com.sap.vocabularies.UI.v1.DataField" /* DataField */ || li.$Type === "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */)) {
            filteredEntityTypes.LineItems.push(entity.name);
        }
        if (Facets && !Facets.qualifier) {
            filteredEntityTypes.Facets.push(entity.name);
        }
    }
    return filteredEntityTypes;
}
function getEntitySetByEntitySetName(entitySetName, oDataServiceAVT) {
    return oDataServiceAVT?.entitySets && oDataServiceAVT.entitySets.find((es) => es.name === entitySetName);
}
exports.getEntitySetByEntitySetName = getEntitySetByEntitySetName;
/**
 * The function generates one app schema per entitySet that is linked with an object page in V2
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Schema} genericSchemas - The generic schemas
 * @param {Schema} appSchemas - the list of app schemas that shall get extended
 */
function generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas) {
    const allPages = appProvider_1.getPages(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_OBJECT_PAGE);
    for (const page in allPages) {
        const entitySetName = allPages[page].entitySet;
        const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
        const entityTypeName = entitySet?.entityType?.name;
        const schemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.ObjectPage, entitySet?.name || entitySetName);
        const genericSchemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.ObjectPage);
        appSchemas[schemaFile.filename] = generate_1.generateObjectPageSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename], entityTypeName);
    }
}
/**
 * The function generates one app schema per entitySet that is linked with an object page in V4
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {Schemas} appSchemas - the list of app schemas that shall get extended
 */
function generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas) {
    const pages = app_1.getPages(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_OBJECT_PAGE);
    for (const page in pages) {
        const entitySetName = pages[page].options.settings.entitySet;
        const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
        if (!entitySet) {
            extensionLogger_1.log(generateParameters.logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('ENTITYSETNOTFOUND', { entitySet: entitySetName }),
                location: {
                    path: ux_specification_types_1.METADATAPATH
                }
            });
        }
        const entityTypeName = entitySet?.entityType?.name;
        const schemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.ObjectPage, entitySet?.name || entitySetName);
        const genericSchemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.ObjectPage);
        appSchemas[schemaFile.filename] = generate_2.generateObjectPageSchemaV4(generateParameters, genericSchemas[genericSchemaFile.filename], entityTypeName);
    }
}
/**
 * Generates all app specific schemas for a Fiori Elements V2 application
 * @param {GenerateSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types, as comprised in oDataServiceAVT
 * @param {TemplateType} templateType - the given Fiori Elements' template type
 */
function generateAppSchemasV2(generateParameters, genericSchemas, uiEntityTypes, templateType) {
    const appSchemas = {};
    if (templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV2 && uiEntityTypes) {
        /*--- List Report ----*/
        const allPages = appProvider_1.getPages(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_LIST_REPORT);
        for (const page in allPages) {
            const entitySetName = allPages[page].entitySet;
            const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
            const entityTypeName = entitySet?.entityType?.name;
            const schemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.ListReport, entitySet?.name || entitySetName);
            const genericSchemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.ListReport);
            appSchemas[schemaFile.filename] = generate_1.generateListReportSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename], entityTypeName);
        }
        /*--- Object Pages ----*/
        generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas);
    }
    else if (templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV2 && uiEntityTypes) {
        /*--- Analytical List Page ----*/
        const allPages = appProvider_1.getPages(generateParameters.manifest[ux_specification_types_1.ManifestSection.generic].pages, ux_specification_types_1.v2.FE_TEMPLATE_V2_ALP);
        for (const page in allPages) {
            const entitySetName = allPages[page].entitySet;
            const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
            const entityTypeName = entitySet?.entityType?.name;
            const schemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.AnalyticalListPage, entitySet?.name || entitySetName);
            const genericSchemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.AnalyticalListPage);
            appSchemas[schemaFile.filename] = generate_1.generateAnalyticalListReportSchemaV2(generateParameters, genericSchemas[genericSchemaFile.filename], entityTypeName);
        }
        /*--- Object Pages ----*/
        generateObjectPageSchemasV2(generateParameters, genericSchemas, appSchemas);
    }
    else if (templateType === ux_specification_types_1.TemplateType.OverviewPageV2) {
        /*--- Overview Page ----*/
        const schemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.OverviewPage);
        const genericSchemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.OverviewPage);
        appSchemas[schemaFile.filename] = generate_1.generateOVPInterfaceV2(genericSchemas[genericSchemaFile.filename], generateParameters.manifest);
    }
    return { ...genericSchemas, ...appSchemas };
}
/**
 * Generates all app specific schemas for a Fiori Elements V4 application
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {Schemas} genericSchemas - The generic schemas
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types, as comprised in oDataServiceAVT
 * @param {TemplateType} templateType - the given Fiori Elements' template type
 */
function generateAppSchemasV4(generateParameters, genericSchemas, uiEntityTypes, templateType) {
    const appSchemas = {};
    if (uiEntityTypes) {
        if (templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV4 ||
            templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV4) {
            /*--- List Report ----*/
            const lrPages = app_1.getPages(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_LIST_REPORT);
            const alpPages = app_1.getPages(generateParameters.manifest, ux_specification_types_1.v4.FE_TEMPLATE_V4_ALP);
            const pages = { ...lrPages, ...alpPages };
            for (const pageId in pages) {
                const entitySetName = pages[pageId].options.settings.entitySet;
                const entitySet = getEntitySetByEntitySetName(entitySetName, generateParameters.serviceAVT);
                const schemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.ListReport, entitySet?.name || entitySetName);
                const genericSchemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.ListReport);
                appSchemas[schemaFile.filename] = generate_2.generateListReportSchemaV4(generateParameters, genericSchemas[genericSchemaFile.filename], entitySet, pages[pageId].name);
            }
            /*--- Object Pages ----*/
            generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas);
        }
        else if (templateType === ux_specification_types_1.TemplateType.FreestylePageV4) {
            const genericSchemaFile = utils_1.getSchemaFilePath(ux_specification_types_1.SchemaType.FreestylePage);
            appSchemas[genericSchemaFile.filename] = generate_2.generateFreestyleSchemaV4(generateParameters, genericSchemas[genericSchemaFile.filename]);
            generateObjectPageSchemasV4(generateParameters, genericSchemas, appSchemas);
        }
    }
    return { ...genericSchemas, ...appSchemas };
}
/**
 * Generates app specific schemas by adding annotation information to copies of the generic schemas, thus replacing all generic definitions.
 * @param {GenerateAppSchemaParameters} generateParameters - list of API input parameters
 * @param {UiEntityTypes} uiEntityTypes - list of all entity types from the service metadata
 * @param templateType - type of the Fiori Elements' template
 */
async function generateAppSchemas(generateParameters, uiEntityTypes, templateType) {
    const genericSchemas = await getGenericSchemas(templateType, generateParameters.fioriElementsVersion);
    if (generateParameters.fioriElementsVersion === ux_specification_types_1.FioriElementsVersion.v4) {
        return generateAppSchemasV4(generateParameters, genericSchemas, uiEntityTypes, templateType);
    }
    else {
        return generateAppSchemasV2(generateParameters, genericSchemas, uiEntityTypes, templateType);
    }
}
/**
 * Imports manifest and flex changes into configuration files with aid of the relevant app provider
 * @param {Manifest} manifest - manifest.json file content of the app in JSON format
 * @param {string[]} flex - list of all UI flexibility changes
 * @param {Schemas} appSchemas - list of app-specific schemas
 * @param {TemplateType} templateType - type of the Fiori Elements' template
 * @param {FileData[]} fragments - extension fragments with their file content
 * @param {ExtensionLogger} logger - logger instance for messages
 *
 * @returns {File[]} a list of all configuration files as generated by the function
 */
function importConfigs(manifest, flex, appSchemas, templateType, fragments, logger) {
    let provider;
    const files = [];
    switch (templateType) {
        case ux_specification_types_1.TemplateType.ListReportObjectPageV2:
        case ux_specification_types_1.TemplateType.AnalyticalListPageV2:
            provider = new appProvider_1.V2AppProvider(manifest, flex, appSchemas, fragments, logger);
            break;
        case ux_specification_types_1.TemplateType.AnalyticalListPageV4:
        case ux_specification_types_1.TemplateType.ListReportObjectPageV4:
            provider = new app_1.V4AppProvider(manifest, appSchemas, templateType, undefined, logger);
            break;
        case ux_specification_types_1.TemplateType.OverviewPageV2:
            provider = new ovpProvider_1.V2OvpProvider(manifest, appSchemas, logger);
            break;
        case ux_specification_types_1.TemplateType.FreestylePageV4:
            provider = new app_1.V4FreestyleAppProvider(manifest, appSchemas, templateType, undefined, logger);
            break;
        default:
            break;
    }
    if (provider) {
        const { appConfig, pageConfigs } = provider.createConfigFiles();
        for (const app in appConfig) {
            files.push({ dataSourceUri: app, fileContent: JSON.stringify(appConfig[app], null, 4) });
        }
        for (const config in pageConfigs) {
            files.push({ dataSourceUri: config, fileContent: JSON.stringify(pageConfigs[config], null, 4) });
        }
    }
    return files;
}
function getFileList(schema, configs) {
    let files = [];
    for (const schemaName of Object.keys(schema).sort()) {
        let dataSourceUri;
        if (schemaName === ux_specification_types_1.SchemaType.Application) {
            dataSourceUri = `${ux_specification_types_1.DirName.Schemas}/${ux_specification_types_1.FileName.App[0].toUpperCase()}${ux_specification_types_1.FileName.App.slice(1)}`;
        }
        else {
            dataSourceUri = `${ux_specification_types_1.DirName.Schemas}/${schemaName}.json`;
        }
        files.push({ dataSourceUri, fileContent: JSON.stringify(schema[schemaName], null, 4) });
    }
    if (configs) {
        files = files.concat(configs);
    }
    return files;
}
/**
 * Import the schema and config files for a given project
 * @param {ImportProjectParameters} importParameters - files of the project: manifest, flex changes, odata files
 */
async function importProjectSchema(importProjectParameters) {
    // Initialize i18next
    i18n_1.initI18n();
    const fioriElementsVersion = utils_1.getVersionFromManifest(importProjectParameters.manifest);
    const service = utils_1.parseAndMergeAndConvert(importProjectParameters.annotations, importProjectParameters.logger);
    const uiEntityTypes = getAnnotationsForUi(service);
    const templateType = utils_1.getTemplateTypeFromManifest(importProjectParameters.manifest, fioriElementsVersion, importProjectParameters.logger);
    const generateParameters = {
        templateType,
        manifest: importProjectParameters.manifest,
        serviceAVT: service,
        fragments: importProjectParameters.fragments,
        fioriElementsVersion,
        logger: importProjectParameters.logger
    };
    const appSchemas = await generateAppSchemas(generateParameters, uiEntityTypes, templateType);
    return getFileList(appSchemas);
}
exports.importProjectSchema = importProjectSchema;
/**
 * Import the schema and config files for a given project
 * @param {ImportProjectParameters} importParameters - files of the project: manifest, flex changes, odata files
 */
async function importProjectSchemaAndConfig(importProjectParameters) {
    // Initialize i18next
    i18n_1.initI18n();
    let configFiles = [];
    const { manifest, annotations, flex, fragments, logger } = importProjectParameters;
    const fioriElementsVersion = utils_1.getVersionFromManifest(manifest);
    const oDataServiceAVT = utils_1.parseAndMergeAndConvert(annotations, logger);
    const templateType = utils_1.getTemplateTypeFromManifest(manifest, fioriElementsVersion, logger);
    const generateParameters = {
        templateType,
        manifest: importProjectParameters.manifest,
        serviceAVT: oDataServiceAVT,
        fragments: importProjectParameters.fragments,
        fioriElementsVersion,
        logger: importProjectParameters.logger
    };
    const uiEntityTypes = getAnnotationsForUi(oDataServiceAVT);
    const appSchemas = await generateAppSchemas(generateParameters, uiEntityTypes, templateType);
    configFiles = importConfigs(manifest, flex, appSchemas, templateType, fragments, logger);
    return getFileList(appSchemas, configFiles);
}
exports.importProjectSchemaAndConfig = importProjectSchemaAndConfig;
//# sourceMappingURL=importProject.js.map