"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformRoutingV4 = exports.Constants = void 0;
const ux_specification_types_1 = require("@sap/ux-specification-types");
var Constants;
(function (Constants) {
    Constants["OptionalQuery"] = ":?query:";
    Constants["Component"] = "sap/fe/AppComponent";
    Constants["Namespace"] = "sap.fe.templates";
})(Constants = exports.Constants || (exports.Constants = {}));
/**
 * Transform Pages(from app.json) to UI5 routing configuration(manifest.json)
 * @param routing UI5 routing configuration
 */
const createRoute = (pattern, name, target) => {
    return {
        pattern,
        name,
        target
    };
};
/**
 * Method returns SapUi5RoutingTargetBase.options object.
 * @param {string} [entitySet] - Entity set.
 * @param {string} [variantManagement] - Variant management string.
 * @return {{settings: SapUi5RoutingTargetSettings}} Returns object for SapUi5RoutingTargetBase.options.
 */
const createTargetOption = (entitySet, variantManagement) => {
    return {
        settings: {
            ...(entitySet && { entitySet }),
            ...(variantManagement && { variantManagement }),
            navigation: {}
        }
    };
};
function initializeRouting(manifestRouting) {
    let routing = manifestRouting;
    if (!routing) {
        routing = {
            routes: [],
            targets: {}
        };
    }
    else {
        if (!routing.routes) {
            routing.routes = [];
        }
        if (!routing.targets) {
            routing.targets = {};
        }
    }
    return routing;
}
function setTargetOptions(target, keyInManifest, navigationEntry) {
    if (!target.options.settings.navigation) {
        target.options.settings.navigation = {};
    }
    target.options.settings.navigation[keyInManifest] = {
        detail: navigationEntry
    };
}
/**
 * Calculates the query pattern for new target entries of the manifest
 * @param parts - array of strings, each entry represents one navigation
 * @param pages - list of all pages
 * @returns the query pattern for the new target
 */
function calculateQueryPattern(parts, pages) {
    let pattern = '';
    parts.forEach((part, index) => {
        const targetPage = pages[part];
        let key = '';
        if (targetPage?.pageType !== ux_specification_types_1.PageTypeV4.ListReport) {
            // Keys should be like - 'key', 'key2', 'key3'
            key = `({key${index ? index + 1 : ''}})`;
        }
        const partToInsert = targetPage?.entitySet ? targetPage.entitySet : part;
        pattern += `${pattern ? '/' : ''}${partToInsert}${key}`;
    });
    return `${pattern}${Constants.OptionalQuery}`;
}
/**
 * Recursive function to determine all parts to combine the query pattern, by traversing the routing navigation links
 * @param parts - list of query parts, to be enhanced per call
 * @param navKey - the key of the given routing navigation entry
 * @param pages - list of all pages
 * @param pageId - key of the current page
 */
function getAllNavigationParts(parts, navKey, pages, pageId) {
    parts.push(navKey);
    let referringPage;
    for (const key in pages) {
        if (typeof pages[key].navigation === 'object') {
            const pageKey = Object.keys(pages[key].navigation).find((index) => pages[key].navigation[index]['route'] === pageId);
            if (pageKey) {
                navKey = pageKey;
                referringPage = pages[key];
            }
        }
        if (referringPage) {
            getAllNavigationParts(parts, navKey, pages, key);
            break;
        }
    }
}
/**
 * Updates the route navigation entries of a page
 * @param page - the current page
 * @param pages - all pages in manifest
 * @param target - the given routing target
 * @param routing - the current routing
 * @param pageId - key of the page in manifest
 */
function handlePageNavigation(page, pages, target, routing, pageId) {
    if (page.navigation) {
        for (const keyInManifest in page.navigation) {
            const navigationEntry = page.navigation[keyInManifest];
            setTargetOptions(target, keyInManifest, navigationEntry);
            if (navigationEntry?.['route']) {
                if (!routing.routes.some((routingRoute) => routingRoute.name === navigationEntry['route'])) {
                    const parts = [];
                    getAllNavigationParts(parts, keyInManifest, pages, pageId);
                    const partsInRightOrder = [...parts].reverse();
                    const pattern = calculateQueryPattern(partsInRightOrder, pages);
                    // Make sure there no route duplication
                    routing.routes.push(createRoute(pattern, navigationEntry['route'], navigationEntry['route']));
                }
            }
        }
    }
}
function removeDeletedPages(routing, pages) {
    for (const id in routing.targets) {
        if (!pages || !pages[id]) {
            // Remove target
            delete routing.targets[id];
            // Remove routes
            const index = routing.routes.findIndex((route) => route.name === id);
            if (index !== -1) {
                routing.routes.splice(index, 1);
            }
        }
    }
}
function transferEntitySet(page, target) {
    if (page.entitySet) {
        if (!target.options) {
            target.options = createTargetOption(page.entitySet, page.variantManagement);
        }
        target.options.settings.entitySet = page.entitySet;
    }
    else {
        delete target.options?.settings?.entitySet;
    }
}
/**
 * Method detects removed custom sections and deletes removed custom sections from manifest.
 * @param page current page
 * @param target routing target to be filled
 */
function deleteRemovedCustomSections(page, target) {
    // Delete removed custom sections
    const manifestSections = target?.options?.settings?.content?.body?.sections;
    if (page.pageType === ux_specification_types_1.PageTypeV4.ObjectPage && manifestSections && typeof manifestSections === 'object') {
        const objectPage = page.config;
        const customSections = Array.isArray(objectPage?.sections?.custom) ? objectPage.sections.custom : [];
        const latestIds = customSections.map((section) => section.id);
        const existingIds = Object.keys(manifestSections);
        for (const id of existingIds) {
            if (!latestIds.includes(id)) {
                // Delete removed custom section
                delete manifestSections[id];
            }
        }
    }
}
function updateRoute(routing, id, page) {
    const route = routing.routes.find((routingRoute) => routingRoute.name === id);
    if (route) {
        if (page.defaultLayoutType) {
            route.layout = page.defaultLayoutType;
        }
        else {
            delete route.layout;
        }
    }
}
/**
 * Fills target with page information
 * @param page current page
 * @param target routing target to be filled
 * @param id page id
 * @param pages all pages of app.json
 * @returns filled target
 */
function fillTarget(page, target, id, pages) {
    if (page.pageType && ![ux_specification_types_1.PageTypeV4.CustomPage, ux_specification_types_1.PageTypeV4.FPMCustomPage].includes(page.pageType)) {
        target = {
            ...target,
            ...{
                type: 'Component',
                id: target?.['id'] || id,
                name: `${Constants.Namespace}.${pages[id].pageType}`
            }
        };
    }
    else if (page.view &&
        !!target &&
        (target.viewName ||
            target.viewId)) {
        // Existing old syntax for Custom Page
        target = {
            ...target,
            ...{
                viewId: page.view.id,
                viewName: page.view.name,
                path: page.view.path,
                viewType: page.view.viewType
            }
        };
    }
    else if (page.view) {
        target = {
            ...target,
            ...{
                type: 'Component',
                id: page.view.id,
                name: page.view.template || ux_specification_types_1.v4.FE_TEMPLATE_V4_CUSTOM_PAGE,
                viewType: page.view.viewType,
                options: {
                    settings: {
                        viewName: page.view.name
                    }
                }
            }
        };
    }
    return target;
}
/**
 * Transform Pages(from app.json) to UI5 routing configuration (manifest.json)
 * @param routing UI5 routing configuration
 */
function transformRoutingV4(homePage, pages, manifest) {
    const routing = initializeRouting(manifest[ux_specification_types_1.ManifestSection.ui5].routing);
    // add default route
    if (homePage && !routing.routes.some((route) => route.name === homePage)) {
        // Make sure there no route duplication
        routing.routes.push(createRoute(Constants.OptionalQuery, homePage, homePage));
    }
    for (const id in pages) {
        let target;
        const page = pages[id];
        if (routing.targets[id]) {
            target = routing.targets[id];
        }
        target = fillTarget(page, target, id, pages);
        transferEntitySet(page, target);
        deleteRemovedCustomSections(page, target);
        if (target && !page.controlAggregation) {
            delete target.contextPattern;
            delete target.controlAggregation;
        }
        if (target?.options?.settings?.navigation) {
            // We handle page 'navigation' from scratch - clear 'navigation' before handling
            target.options.settings.navigation = {};
        }
        // Handle page 'navigation'
        handlePageNavigation(page, pages, target, routing, id);
        // Update associated route with layout information
        updateRoute(routing, id, page);
        routing.targets[id] = target;
    }
    // Remove deleted pages
    removeDeletedPages(routing, pages);
    return routing;
}
exports.transformRoutingV4 = transformRoutingV4;
//# sourceMappingURL=manifest.js.map