"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAppProvider = exports.getPages = exports.getSettings = exports.getHome = exports.getPagesAndConfigs = exports.unhandledControllers = exports.Constants = void 0;
const appProvider_1 = require("../../../common/appProvider");
const application_1 = require("../../application");
const common_1 = require("../../../common");
const listReport_1 = require("../pages/listReport");
const objectPage_1 = require("../pages/objectPage");
const ux_specification_types_1 = require("@sap/ux-specification-types");
const utils_1 = require("../utils");
const extensionLogger_1 = require("../../../../extensionLogger");
const i18next_1 = __importDefault(require("i18next"));
var Constants;
(function (Constants) {
    Constants["OptionalQuery"] = ":?query:";
    Constants["Component"] = "sap/fe/AppComponent";
    Constants["Namespace"] = "sap.fe.templates";
})(Constants = exports.Constants || (exports.Constants = {}));
// Store controller names which should be handled lately
exports.unhandledControllers = [];
// Store route associations
let associations = {};
/**
 * Sort in following way
 * 1. string targets first
 * 2. Then sort targets as array by elements count - from lowest to highest(ASC)
 * @param {SapUi5RoutingRoute} route1 - First instance of router to compare.
 * @param {SapUi5RoutingRoute} route2 - Second instance of router to compare.
 * @return {number} Compare result.
 */
function routesSorter(route1, route2) {
    const target1 = route1.target;
    const target2 = route2.target;
    const isT1Array = Array.isArray(target1);
    const isT2Array = Array.isArray(target2);
    if (isT1Array && isT2Array) {
        return target1.length - target2.length;
    }
    if (!isT1Array && !isT2Array) {
        return 0;
    }
    return !isT1Array ? -1 : 1;
}
/**
 * Method to resolve target and return target name as string.
 * Thing is that we can receive target as array of targets and we need detect which target is unique target in that array.
 * @param {SapUi5RoutingRouteTarget} target - Target to resolve.
 * @param {Array<string>} usedTargets - Array of resolved targets(which means that those targets are not unique anymore).
 * @return {string} Resolved unique target namet.
 */
function resolveTarget(target, usedTargets = []) {
    if (!Array.isArray(target)) {
        return target;
    }
    let targetParts = target;
    for (const usedTarget of usedTargets) {
        targetParts = targetParts.filter((targetPart) => !usedTarget.includes(targetPart));
    }
    return targetParts[0];
}
/**
 * Method which populates object with routings routes associations.
 * @param {SapUi5RoutingRoute} routes - Routing routes.
 * @return {object} Map object of association routes.
 */
function populateAssociations(routes) {
    const routesAssociations = {};
    routes = routes.concat().sort(routesSorter);
    const resolvedTargets = [];
    for (const route of routes) {
        const parts = route.pattern.split(':')[0].split('/');
        let target;
        if (Array.isArray(route.target)) {
            target = resolveTarget(route.target, resolvedTargets);
            resolvedTargets.push(route.target);
        }
        else {
            target = route.target;
        }
        for (const part of parts) {
            const prop = part.split('(')[0];
            routesAssociations[target] = routesAssociations[target] ? `${routesAssociations[target]}.${prop}` : prop;
        }
    }
    return routesAssociations;
}
/**
 * Determines the page type of a routing target
 * @param target - routing target, as defined in manifest
 * @param logger - logger for error messages
 * @param routingTargetId - ID of the routing target
 * @returns the page type
 */
function determinePageType(target, logger, routingTargetId) {
    let pageType;
    if (target['name']) {
        if (target['name'] === ux_specification_types_1.v4.FE_TEMPLATE_V4_CUSTOM_PAGE) {
            pageType = ux_specification_types_1.PageTypeV4.FPMCustomPage;
        }
        else if (target['name'].endsWith(ux_specification_types_1.PageTypeV4.ListReport) ||
            target['name'].endsWith(ux_specification_types_1.PageTypeV4.AnalyticalListPage)) {
            pageType = ux_specification_types_1.PageTypeV4.ListReport;
        }
        else if (target['name'].endsWith(ux_specification_types_1.PageTypeV4.ObjectPage)) {
            pageType = ux_specification_types_1.PageTypeV4.ObjectPage;
        }
        else {
            pageType = ux_specification_types_1.PageTypeV4.CustomPage;
        }
    }
    else if ('viewId' in target) {
        pageType = ux_specification_types_1.PageTypeV4.CustomPage;
    }
    else {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('INVALIDTARGETDEFINITION', { target: JSON.stringify(target) }),
            location: {
                path: ux_specification_types_1.MANIFESTPATH,
                range: [`${ux_specification_types_1.ManifestSection.ui5}/routing/targets/${routingTargetId}`]
            }
        });
        if (target['viewType'] in ux_specification_types_1.ViewTypes && 'viewName' in target) {
            pageType = ux_specification_types_1.PageTypeV4.CustomPage;
        }
    }
    return pageType;
}
function convertSettingsToConfig(params) {
    const schemaId = common_1.generatePageId(params.page.pageType, params.page.entitySet, params.target['viewId'] || (params.pageType === ux_specification_types_1.PageTypeV4.CustomPage && params.target['id']));
    if (!schemaId) {
        return;
    }
    // Get the JSON schema for the page. If no page specific schema exists, fall back top the generic schema for the page type
    const jsonSchema = Object.keys(params.schemas).find((element) => element.includes(schemaId)) ||
        Object.keys(params.schemas).find((element) => element.includes(schemaId.slice(0, -1))) ||
        Object.keys(params.schemas).find((element) => element.includes(params.page.pageType));
    if (jsonSchema) {
        if (params.page.pageType === ux_specification_types_1.PageTypeV4.ObjectPage) {
            const importParameters = {
                manifest: params.manifest,
                jsonSchema: params.schemas[jsonSchema],
                routingId: params.id,
                logger: params.logger
            };
            params.page.config = objectPage_1.createObjectPageConfigV4(importParameters);
        }
        else if (params.templateType === ux_specification_types_1.TemplateType.ListReportObjectPageV4) {
            const importParameters = {
                manifest: params.manifest,
                jsonSchema: params.schemas[jsonSchema],
                logger: params.logger
            };
            params.page.config = listReport_1.createListReportConfig(importParameters, ux_specification_types_1.SchemaType.ListReport);
        }
        else if (params.templateType === ux_specification_types_1.TemplateType.AnalyticalListPageV4) {
            const importParameters = {
                manifest: params.manifest,
                jsonSchema: params.schemas[jsonSchema],
                logger: params.logger
            };
            params.page.config = listReport_1.createListReportConfig(importParameters, ux_specification_types_1.SchemaType.AnalyticalListPage);
        }
    }
}
/**
 * Updates the class variable collecting the unhandled controllers
 * @param target - current routing target
 */
function updateUnhandledControllers(target) {
    if (target.options) {
        if ('viewName' in target.options.settings) {
            const viewParts = target.options.settings.viewName.split('.');
            exports.unhandledControllers.push(viewParts[viewParts.length - 1]);
        }
    }
    else if ('viewId' in target) {
        // There no 'options' for custom page target -
        //    we need check target's controller source for navigation
        const viewParts = target.viewName.split('.');
        exports.unhandledControllers.push(viewParts[viewParts.length - 1]);
    }
}
/**
 * Evaluates the target options in manifest while setting up the page config.
 * Fills the page navigation object
 * @param {RoutingTargetOptions} target - target definition in manifest
 * @param {Page} page - page config, to be updated
 */
function evaluateTargetOptions(target, page) {
    if (target.options) {
        if (target.options.settings.variantManagement) {
            page.variantManagement = target.options.settings.variantManagement;
        }
        page.navigation = {};
        for (const name in target.options.settings.navigation) {
            const navigationRoute = target.options.settings.navigation[name];
            page.navigation[name] = navigationRoute.detail;
        }
    }
}
/**
 * Checks if the manifest's routing target represents a custom page definition
 * @param {RoutingTargetOptions} target - target definition in manifest
 * @param {Page} page - page config, to be updated
 * @param {PageTypeV4} pageType - page type
 */
function evaluateCustomPageSettings(target, page, pageType) {
    if ('viewId' in target) {
        // Populate view of custom page
        page.view = {
            id: target.viewId,
            name: target.viewName,
            ...(target.viewType && { viewType: target.viewType }),
            ...(target.viewPath && { path: target.viewPath }),
            ...(target.path && { path: target.path })
        };
    }
    else if ([ux_specification_types_1.PageTypeV4.CustomPage, ux_specification_types_1.PageTypeV4.FPMCustomPage].includes(pageType)) {
        const customPageName = target.options?.settings?.viewName || target['viewName'];
        page.view = {
            ...(target.id && { id: target.id }),
            ...(customPageName && { name: customPageName }),
            ...(target.name && { template: target.name }),
            ...(target['viewType'] && { viewType: target['viewType'] })
        };
    }
}
/**
 * Determines the Pages(app.json) using routing configuration from manifest and creates the configuration for each page
 * @param manifest - manifest.json of the app
 * @param schemas - list of JSON schemas of all pages
 */
function getPagesAndConfigs(manifest, schemas, templateType, logger) {
    const pages = {};
    const routing = manifest[ux_specification_types_1.ManifestSection.ui5].routing;
    associations = populateAssociations(routing.routes || []);
    for (const id in routing.targets) {
        const target = routing.targets[id];
        const pageType = determinePageType(target, logger, id);
        const page = { pageType };
        // Entity set
        if (target.options) {
            page.entitySet = target.options.settings.entitySet;
        }
        if (target.controlAggregation) {
            page.controlAggregation = target.controlAggregation;
        }
        if (associations[id] && associations[id].indexOf('.') !== -1) {
            const parts = associations[id].split('.');
            page.navigationProperty = parts[parts.length - 1];
        }
        // Custom page's view object
        evaluateCustomPageSettings(target, page, pageType);
        evaluateTargetOptions(target, page);
        updateUnhandledControllers(target);
        // Get layout from route
        const route = routing.routes.find((routingRoute) => routingRoute.name === 'BookingObjectPage');
        if (route && 'layout' in route) {
            page.defaultLayoutType = route.layout;
        }
        pages[id] = page;
        // convert settings to config
        const conversionParameters = {
            target,
            pageType,
            manifest,
            schemas,
            logger,
            page,
            id,
            templateType
        };
        convertSettingsToConfig(conversionParameters);
    }
    return pages;
}
exports.getPagesAndConfigs = getPagesAndConfigs;
/**
 * Get the id of the page that is to open when the application is started.
 * @param routing UI5 routing configuration
 */
function getHome(routing) {
    let routeHome;
    if (routing && routing.routes && routing.routes.length > 0) {
        for (const route of routing.routes) {
            //find the home, i.e. route which starts with ':?query:' pattern for List Report,
            //resp. doesn't contain '/' for Form Page
            if (route.pattern.startsWith(':?query:')) {
                routeHome = route;
                break;
            }
            else if (route.pattern.indexOf('/') === -1) {
                routeHome = route;
                continue;
            }
        }
        if (routeHome) {
            return resolveTarget(routeHome.target);
        }
        else {
            return resolveTarget(routing.routes[0].target);
        }
    }
    else {
        return undefined;
    }
}
exports.getHome = getHome;
/**
 * Method which detects app settings from manifest.
 * Currently only some settings are detected - Flexible Column Layout, viewPath, viewType, path
 * @param routing UI5 routing configuration.
 * @return {AppSettings} Application settings.
 */
function getSettings(routing) {
    const config = routing.config;
    if (config) {
        return {
            ...(config.flexibleColumnLayout && { flexibleColumnLayout: config.flexibleColumnLayout }),
            ...(config.viewType && { viewType: config.viewType }),
            ...(config.viewPath && { path: config.viewPath }),
            ...(config.path && { path: config.path })
        };
    }
    return undefined;
}
exports.getSettings = getSettings;
function getPages(manifest, targetName) {
    const routing = manifest[ux_specification_types_1.ManifestSection.ui5].routing;
    const pages = {};
    if (routing) {
        for (const id in routing.targets) {
            const v4Page = routing.targets[id];
            if (v4Page['name'] === targetName) {
                pages[id] = v4Page;
            }
        }
    }
    return pages;
}
exports.getPages = getPages;
class BaseAppProvider extends appProvider_1.AppProvider {
    constructor(manifest, schemas, templateType, _settings, logger) {
        // Import settings
        const appSettings = new application_1.AppSettings();
        const schemaFile = common_1.getSchemaFilePath(ux_specification_types_1.SchemaType.Application);
        const appSchema = schemas[schemaFile.filename];
        utils_1.transferSettingsOfObject(appSettings, manifest, appSchema.definitions.AppSettings, '', []);
        super(manifest, schemas, getHome(manifest[ux_specification_types_1.ManifestSection.ui5].routing), getPagesAndConfigs(manifest, schemas, templateType, logger), ux_specification_types_1.FioriElementsVersion.v4, { ...getSettings(manifest[ux_specification_types_1.ManifestSection.ui5].routing), ...appSettings }, logger);
        this.unhandledControllers = exports.unhandledControllers;
    }
}
exports.BaseAppProvider = BaseAppProvider;
//# sourceMappingURL=baseAppProvider.js.map